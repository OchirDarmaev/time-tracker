<style>
  .time-slider-wrapper {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px;
    box-shadow: var(--shadow-sm);
    margin: 16px 0;
  }

  .time-slider-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
  }

  .time-slider-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0;
  }

  .time-slider-controls {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .time-slider-total-label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
  }

  .time-slider-total-input {
    background-color: var(--bg-tertiary);
    border: 1px solid var(--border);
    color: var(--text-primary);
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 12px;
    width: 60px;
  }

  .time-slider-total-input:focus {
    outline: none;
    border-color: #14b8a6;
    box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
  }

  .time-slider-track-container {
    position: relative;
    margin: 16px 0;
  }

  .time-slider-track {
    position: relative;
    height: 64px;
    background: linear-gradient(to right, 
      var(--bg-tertiary) 0%, 
      rgba(20, 184, 166, 0.05) 50%, 
      var(--bg-tertiary) 100%);
    border-radius: 6px;
    border: 1px solid var(--border);
    overflow: visible;
    cursor: pointer;
  }

  .time-slider-labels {
    display: flex;
    justify-content: space-between;
    margin-top: 4px;
    font-size: 10px;
    color: var(--text-tertiary);
  }

  .time-slider-label {
    font-weight: 500;
  }

  .time-slider-segment {
    position: absolute;
    top: 0;
    height: 100%;
    border-radius: 8px;
    transition: left 0.2s ease, width 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    cursor: pointer;
  }

  .time-slider-segment:hover {
    filter: brightness(1.1);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .time-slider-segment-content {
    position: relative;
    z-index: 2;
    text-align: center;
    pointer-events: none;
  }

  .time-slider-segment-name {
    font-size: 12px;
    font-weight: 600;
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    margin-bottom: 1px;
  }

  .time-slider-segment-duration {
    font-size: 10px;
    color: rgba(255, 255, 255, 0.9);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  }

  .time-slider-handle {
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 24px;
    height: 48px;
    background: var(--bg-primary);
    border: 2px solid #14b8a6;
    border-radius: 6px;
    cursor: grab;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    transition: left 0.2s ease;
  }

  .time-slider-handle:hover {
    border-color: #0d9488;
    box-shadow: 0 4px 12px rgba(20, 184, 166, 0.3);
    transform: translate(-50%, -50%) scale(1.1);
  }

  .time-slider-handle:active {
    cursor: grabbing;
  }

  .time-slider-handle.active {
    border-color: #06b6d4;
    box-shadow: 0 0 0 4px rgba(20, 184, 166, 0.2), 
                0 4px 16px rgba(20, 184, 166, 0.4);
    transform: translate(-50%, -50%) scale(1.15);
  }

  .time-slider-handle-bars {
    display: flex;
    gap: 2px;
    align-items: center;
  }

  .time-slider-handle-bar {
    width: 2px;
    height: 20px;
    background: #14b8a6;
    border-radius: 1px;
  }

  .time-slider-handle.active .time-slider-handle-bar {
    background: #06b6d4;
  }

  .time-slider-projects {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid var(--border);
  }

  .time-slider-projects-header {
    margin-bottom: 8px;
  }

  .time-slider-projects-title {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .time-slider-project-chips {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .time-slider-project-chip {
    display: inline-flex;
    align-items: center;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    border: 1px solid var(--border);
    background-color: var(--bg-tertiary);
    color: var(--text-primary);
  }

  .time-slider-project-chip:hover:not(.disabled) {
    background-color: var(--bg-secondary);
    border-color: #14b8a6;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(20, 184, 166, 0.2);
  }

  .time-slider-project-chip.active {
    background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
    color: white;
    border-color: #0d9488;
    box-shadow: 0 2px 8px rgba(20, 184, 166, 0.3);
  }

  .time-slider-project-chip.disabled {
    opacity: 0.4;
    cursor: not-allowed;
    background-color: var(--bg-tertiary);
  }

  .time-slider-segments-info {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid var(--border);
  }

  .time-slider-segment-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background-color: var(--bg-tertiary);
    border-radius: 6px;
    margin-bottom: 6px;
    border: 1px solid var(--border);
  }

  .time-slider-segment-item:hover {
    background-color: var(--bg-secondary);
    border-color: #14b8a6;
  }

  .time-slider-segment-item-info {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .time-slider-segment-item-color {
    width: 16px;
    height: 16px;
    border-radius: 4px;
    flex-shrink: 0;
  }

  .time-slider-segment-item-name {
    font-weight: 500;
    color: var(--text-primary);
    font-size: 12px;
  }

  .time-slider-segment-item-duration {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 600;
  }

  .time-slider-segment-item-remove {
    background: none;
    border: none;
    color: var(--text-tertiary);
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    transition: all 0.2s ease;
  }

  .time-slider-segment-item-remove:hover {
    background-color: rgba(248, 113, 113, 0.1);
    color: var(--error);
  }

  .time-slider-empty-state {
    text-align: center;
    padding: 48px 24px;
    color: var(--text-tertiary);
    font-size: 14px;
  }

  .time-slider-empty-state-text {
    margin-bottom: 16px;
  }

  .time-slider-sync-status {
    display: flex;
    align-items: center;
  }

  .time-slider-sync-icon {
    font-size: 14px;
    font-weight: 500;
    transition: color 0.2s ease;
  }

  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }

  .pulse-animation {
    animation: pulse 1.5s ease-in-out infinite;
  }

</style>

<script>
  if (!window.TimeSlider) {
    class TimeSlider {
    constructor(containerId, options = {}) {
      this.container = document.getElementById(containerId);
      if (!this.container) {
        throw new Error(`Container with id "${containerId}" not found`);
      }

      this.totalHours = options.totalHours || 8;
      this.snapIncrement = options.snapIncrement || 30; // minutes
      this.segments = options.segments || [];
      this.projects = options.projects || [];
      this.onChange = options.onChange || (() => {});
      this.date = options.date || new Date().toISOString().split('T')[0];
      this.editingNoteIndex = null;
      this.syncTimeout = null;
      this.isSyncing = false;

      this.activeHandle = null;
      this.dragStartX = 0;
      this.dragStartPosition = 0;
      this.trackWidth = 0;
      this.rafId = null;

      this.projectColors = this.generateProjectColors();
      this.init();
    }

    generateProjectColors() {
      // This method is kept for backward compatibility but is no longer used
      // Colors are now stored in project.color
      const defaultColors = [
        { bg: 'linear-gradient(135deg, #14b8a6 0%, #0d9488 100%)', solid: '#14b8a6' },
        { bg: 'linear-gradient(135deg, #06b6d4 0%, #0891b2 100%)', solid: '#06b6d4' },
        { bg: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)', solid: '#3b82f6' },
        { bg: 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)', solid: '#8b5cf6' },
        { bg: 'linear-gradient(135deg, #ec4899 0%, #db2777 100%)', solid: '#ec4899' },
        { bg: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', solid: '#f59e0b' },
        { bg: 'linear-gradient(135deg, #10b981 0%, #059669 100%)', solid: '#10b981' },
        { bg: 'linear-gradient(135deg, #6366f1 0%, #4f46e5 100%)', solid: '#6366f1' },
      ];
      return defaultColors;
    }

    getProjectColor(projectId) {
      const project = this.projects.find(p => p.id === projectId);
      if (project && project.color) {
        // Convert hex color to RGB for darker shade calculation
        const hex = project.color.replace('#', '');
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        // Create darker shade (reduce by ~15%)
        const darkerR = Math.max(0, Math.floor(r * 0.85));
        const darkerG = Math.max(0, Math.floor(g * 0.85));
        const darkerB = Math.max(0, Math.floor(b * 0.85));
        const darkerHex = '#' + [darkerR, darkerG, darkerB].map(x => {
          const hex = x.toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        }).join('');
        return {
          bg: `linear-gradient(135deg, ${project.color} 0%, ${darkerHex} 100%)`,
          solid: project.color
        };
      }
      // Fallback to default colors if project color is not available
      const index = this.projects.findIndex(p => p.id === projectId);
      return this.projectColors[index >= 0 ? index % this.projectColors.length : 0];
    }

    init() {
      this.setupEventListeners();
      this.render();
    }

    setupEventListeners() {
      const totalInput = this.container.querySelector('#total-hours-input');
      if (totalInput) {
        totalInput.addEventListener('change', (e) => {
          this.totalHours = parseFloat(e.target.value) || 8;
          this.render();
          this.scheduleSync();
        });
      }
    }

    hoursToMinutes(hours) {
      return Math.round(hours * 60);
    }

    minutesToHours(minutes) {
      return minutes / 60;
    }

    snapToIncrement(minutes) {
      return Math.round(minutes / this.snapIncrement) * this.snapIncrement;
    }

    render() {
      this.renderTrack();
      this.renderProjectChips();
      this.renderSegmentsInfo();
    }

    renderTrack() {
      const track = this.container.querySelector('#time-slider-track');
      const endLabel = this.container.querySelector('#time-slider-end-label');
      
      if (!track) return;

      track.innerHTML = '';
      this.trackWidth = track.offsetWidth;

      if (endLabel) {
        endLabel.textContent = `${this.totalHours}h`;
      }

      if (this.segments.length === 0) {
        track.innerHTML = '<div class="time-slider-empty-state" style="display: flex; align-items: center; justify-content: center; height: 100%; width: 100%;"><div class="time-slider-empty-state-text" style="text-align: center; color: var(--text-tertiary); font-size: 12px;">Click a project chip to add a time segment</div></div>';
        return;
      }

      let currentPosition = 0;
      const totalMinutes = this.hoursToMinutes(this.totalHours);

      this.segments.forEach((segment, index) => {
        const segmentMinutes = segment.minutes || 0;
        const segmentWidth = (segmentMinutes / totalMinutes) * 100;
        const leftPercent = (currentPosition / totalMinutes) * 100;

        const segmentEl = this.createSegmentElement(segment, leftPercent, segmentWidth, index);
        track.appendChild(segmentEl);

        // Add handle after each segment (except the last one)
        if (index < this.segments.length - 1) {
          const handlePosition = leftPercent + segmentWidth;
          const handleEl = this.createHandleElement(handlePosition, index);
          track.appendChild(handleEl);
        }

        currentPosition += segmentMinutes;
      });
    }

    createSegmentElement(segment, leftPercent, widthPercent, index) {
      const segmentEl = document.createElement('div');
      segmentEl.className = 'time-slider-segment';
      segmentEl.style.left = `${leftPercent}%`;
      segmentEl.style.width = `${widthPercent}%`;
      
      const color = this.getProjectColor(segment.project_id);
      segmentEl.style.background = color.bg;
      segmentEl.dataset.segmentIndex = index;
      segmentEl.dataset.projectId = segment.project_id;

      const content = document.createElement('div');
      content.className = 'time-slider-segment-content';
      
      const name = document.createElement('div');
      name.className = 'time-slider-segment-name';
      const project = this.projects.find(p => p.id === segment.project_id);
      name.textContent = project ? project.name : 'Unknown';
      
      const duration = document.createElement('div');
      duration.className = 'time-slider-segment-duration';
      duration.textContent = `${this.minutesToHours(segment.minutes).toFixed(1)}h`;

      content.appendChild(name);
      content.appendChild(duration);
      segmentEl.appendChild(content);

      segmentEl.addEventListener('click', () => {
        this.removeSegment(index);
      });

      return segmentEl;
    }

    createHandleElement(positionPercent, handleIndex) {
      const handleEl = document.createElement('div');
      handleEl.className = 'time-slider-handle';
      handleEl.style.left = `${positionPercent}%`;
      handleEl.dataset.handleIndex = handleIndex;

      const bars = document.createElement('div');
      bars.className = 'time-slider-handle-bars';
      
      for (let i = 0; i < 3; i++) {
        const bar = document.createElement('div');
        bar.className = 'time-slider-handle-bar';
        bars.appendChild(bar);
      }

      handleEl.appendChild(bars);

      this.attachHandleEvents(handleEl, handleIndex);

      return handleEl;
    }

    attachHandleEvents(handleEl, handleIndex) {
      handleEl.addEventListener('mousedown', (e) => this.startDrag(e, handleIndex));
      handleEl.addEventListener('touchstart', (e) => this.startDrag(e, handleIndex), { passive: false });
    }

    startDrag(e, handleIndex) {
      e.preventDefault();
      e.stopPropagation();

      this.activeHandle = handleIndex;
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      this.dragStartX = clientX;

      const handle = this.container.querySelector(`[data-handle-index="${handleIndex}"]`);
      if (handle) {
        handle.classList.add('active');
        const rect = handle.getBoundingClientRect();
        this.dragStartPosition = parseFloat(handle.style.left);
      }

      document.addEventListener('mousemove', this.handleDrag);
      document.addEventListener('mouseup', this.stopDrag);
      document.addEventListener('touchmove', this.handleDrag, { passive: false });
      document.addEventListener('touchend', this.stopDrag);
    }

    handleDrag = (e) => {
      if (this.activeHandle === null) return;

      e.preventDefault();
      
      // Cancel any pending animation frame
      if (this.rafId !== null) {
        cancelAnimationFrame(this.rafId);
      }
      
      // Use requestAnimationFrame to throttle updates
      this.rafId = requestAnimationFrame(() => {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const track = this.container.querySelector('#time-slider-track');
        if (!track) return;

        const trackRect = track.getBoundingClientRect();
        const deltaX = clientX - this.dragStartX;
        const deltaPercent = (deltaX / trackRect.width) * 100;
        const newPosition = Math.max(0, Math.min(100, this.dragStartPosition + deltaPercent));

        this.updateHandlePosition(this.activeHandle, newPosition);
        this.rafId = null;
      });
    };

    stopDrag = () => {
      // Cancel any pending animation frame
      if (this.rafId !== null) {
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
      }

      if (this.activeHandle !== null) {
        const handle = this.container.querySelector(`[data-handle-index="${this.activeHandle}"]`);
        if (handle) {
          handle.classList.remove('active');
        }
        this.activeHandle = null;
        // Full re-render only when drag is complete
        this.render();
        this.scheduleSync();
      }

      document.removeEventListener('mousemove', this.handleDrag);
      document.removeEventListener('mouseup', this.stopDrag);
      document.removeEventListener('touchmove', this.handleDrag);
      document.removeEventListener('touchend', this.stopDrag);
    };

    updateHandlePosition(handleIndex, positionPercent) {
      const totalMinutes = this.hoursToMinutes(this.totalHours);
      const positionMinutes = (positionPercent / 100) * totalMinutes;
      const snappedMinutes = Math.max(0, Math.min(totalMinutes, this.snapToIncrement(positionMinutes)));
      const snappedPercent = (snappedMinutes / totalMinutes) * 100;

      const handle = this.container.querySelector(`[data-handle-index="${handleIndex}"]`);
      if (!handle) return;

      // Update adjacent segments
      const segmentBefore = this.segments[handleIndex];
      const segmentAfter = this.segments[handleIndex + 1];

      if (segmentBefore && segmentAfter) {
        const currentBoundary = this.getCurrentBoundaryPosition(handleIndex);
        const newBoundary = snappedMinutes;

        const delta = newBoundary - currentBoundary;
        let segmentBeforeMinutes = this.snapToIncrement(segmentBefore.minutes + delta);
        let segmentAfterMinutes = this.snapToIncrement(segmentAfter.minutes - delta);

        // Ensure minimum segment size (30 minutes to match snap increment)
        const minMinutes = 30;
        if (segmentBeforeMinutes >= minMinutes && segmentAfterMinutes >= minMinutes) {
          // Update segment data
          segmentBefore.minutes = segmentBeforeMinutes;
          segmentAfter.minutes = segmentAfterMinutes;
          
          // Update visual positions without full re-render
          this.updateSegmentVisuals(handleIndex, snappedPercent);
        } else {
          // Revert handle position if constraints violated
          const revertPercent = (currentBoundary / totalMinutes) * 100;
          handle.style.left = `${revertPercent}%`;
        }
      }
    }

    updateSegmentVisuals(handleIndex, handlePercent) {
      // Update handle position
      const handle = this.container.querySelector(`[data-handle-index="${handleIndex}"]`);
      if (handle) {
        handle.style.left = `${handlePercent}%`;
      }

      // Update segment positions and widths without full re-render
      const totalMinutes = this.hoursToMinutes(this.totalHours);
      let currentPosition = 0;

      this.segments.forEach((segment, index) => {
        const segmentEl = this.container.querySelector(`[data-segment-index="${index}"]`);
        if (!segmentEl) return;

        const segmentWidth = (segment.minutes / totalMinutes) * 100;
        const leftPercent = (currentPosition / totalMinutes) * 100;

        segmentEl.style.left = `${leftPercent}%`;
        segmentEl.style.width = `${segmentWidth}%`;

        // Update segment duration text
        const durationEl = segmentEl.querySelector('.time-slider-segment-duration');
        if (durationEl) {
          durationEl.textContent = `${this.minutesToHours(segment.minutes).toFixed(1)}h`;
        }

        currentPosition += segment.minutes;
      });

      // Update segments info without full re-render
      this.updateSegmentsInfoOnly();
    }

    updateSegmentsInfoOnly() {
      const infoContainer = this.container.querySelector('#time-slider-segments-info');
      if (!infoContainer) return;

      if (this.segments.length === 0) {
        infoContainer.innerHTML = '';
        return;
      }

      // Update duration values for each segment item
      const segmentItems = infoContainer.querySelectorAll('.time-slider-segment-item');
      this.segments.forEach((segment, index) => {
        if (segmentItems[index]) {
          const durationEl = segmentItems[index].querySelector('.time-slider-segment-item-duration');
          if (durationEl) {
            const hours = this.minutesToHours(segment.minutes);
            durationEl.textContent = `${hours.toFixed(1)}h`;
          }
        }
      });
    }

    getCurrentBoundaryPosition(handleIndex) {
      let position = 0;
      for (let i = 0; i <= handleIndex; i++) {
        position += this.segments[i].minutes;
      }
      return position;
    }

    renderProjectChips() {
      const chipsContainer = this.container.querySelector('#time-slider-project-chips');
      if (!chipsContainer) return;

      chipsContainer.innerHTML = '';

      // Sort projects: regular projects first, then system projects
      const sortedProjects = [...this.projects].sort((a, b) => {
        const aIsSystem = a.isSystem || false;
        const bIsSystem = b.isSystem || false;
        // Regular projects (isSystem = false) come first
        if (aIsSystem !== bIsSystem) {
          return aIsSystem ? 1 : -1;
        }
        // Within same category, sort alphabetically by name
        return a.name.localeCompare(b.name);
      });

      sortedProjects.forEach(project => {
        const chip = document.createElement('div');
        chip.className = 'time-slider-project-chip';
        chip.textContent = project.name;
        chip.dataset.projectId = project.id;

        // Apply project color to chip
        if (project.color) {
          const color = this.getProjectColor(project.id);
          chip.style.borderColor = color.solid;
          chip.style.color = color.solid;
        }

        const isUsed = this.segments.some(s => s.project_id === project.id);
        if (isUsed) {
          chip.classList.add('active');
          // Apply active state with project color
          if (project.color) {
            const color = this.getProjectColor(project.id);
            chip.style.background = color.bg;
            chip.style.borderColor = color.solid;
            chip.style.color = 'white';
          }
        }

        if (project.suppressed) {
          chip.classList.add('disabled');
        } else {
          chip.addEventListener('click', () => {
            this.toggleProject(project.id);
          });
        }

        chipsContainer.appendChild(chip);
      });
    }

    toggleProject(projectId) {
      const existingIndex = this.segments.findIndex(s => s.project_id === projectId);
      
      if (existingIndex !== -1) {
        // Project exists, remove it
        this.removeSegment(existingIndex);
      } else {
        // Project doesn't exist, add it
        this.addSegment(projectId);
      }
    }

    addSegment(projectId) {
      const totalMinutes = this.hoursToMinutes(this.totalHours);
      
      // First segment: use full Total Hours value (snapped to 30 min increments)
      if (this.segments.length === 0) {
        this.segments.push({
          project_id: projectId,
          minutes: this.snapToIncrement(totalMinutes),
          comment: null,
        });
      } else {
        // When adding a new project, redistribute time among all segments (including new one)
        // Offset existing workloads to make room for the new segment
        const newSegmentCount = this.segments.length + 1;
        let minutesPerSegment = Math.floor(totalMinutes / newSegmentCount);
        // Snap to 30-minute increments
        minutesPerSegment = this.snapToIncrement(minutesPerSegment);
        const totalAllocated = minutesPerSegment * newSegmentCount;
        const remainder = totalMinutes - totalAllocated;
        
        // Redistribute time to existing segments (snapped to 30 min)
        this.segments.forEach(segment => {
          segment.minutes = minutesPerSegment;
        });
        
        // Add new segment with its share, plus any remainder (snapped to 30 min)
        this.segments.push({
          project_id: projectId,
          minutes: this.snapToIncrement(minutesPerSegment + remainder),
          comment: null,
        });
      }

      this.render();
      this.scheduleSync();
    }

    scheduleSync() {
      // Show "Saving..." immediately when timer starts
      this.updateSyncIcon('syncing');
      
      // Clear existing timeout
      if (this.syncTimeout) {
        clearTimeout(this.syncTimeout);
      }
      
      // Schedule sync after 1.5 seconds
      this.syncTimeout = setTimeout(() => {
        this.sync();
      }, 1500);
    }

    sync() {
      if (this.isSyncing) return;
      
      this.isSyncing = true;
      
      // Call onChange callback which should handle the sync
      this.onChange(this.getSegmentsData());
      
      // Reset sync state after a delay
      setTimeout(() => {
        this.isSyncing = false;
        this.updateSyncIcon('synced');
      }, 500);
    }

    updateSyncIcon(state) {
      const syncIcon = document.getElementById('time-slider-sync-icon');
      if (!syncIcon) return;
      
      if (state === 'syncing') {
        syncIcon.innerHTML = 'Saving...';
        syncIcon.style.color = 'var(--accent)';
        syncIcon.classList.add('pulse-animation');
      } else {
        // synced or default
        syncIcon.innerHTML = 'Synced';
        syncIcon.style.color = 'var(--success)';
        syncIcon.classList.remove('pulse-animation');
      }
    }

    removeSegment(index) {
      // Remove the segment
      this.segments.splice(index, 1);
      
      // If there are remaining segments, redistribute the removed segment's time
      if (this.segments.length > 0) {
        const totalMinutes = this.hoursToMinutes(this.totalHours);
        let minutesPerSegment = Math.floor(totalMinutes / this.segments.length);
        // Snap to 30-minute increments
        minutesPerSegment = this.snapToIncrement(minutesPerSegment);
        const totalAllocated = minutesPerSegment * this.segments.length;
        const remainder = totalMinutes - totalAllocated;
        
        // Redistribute time to remaining segments (snapped to 30 min)
        this.segments.forEach((segment, idx) => {
          segment.minutes = this.snapToIncrement(minutesPerSegment + (idx === 0 ? remainder : 0));
        });
      }
      
      this.render();
      this.scheduleSync();
    }

    renderSegmentsInfo() {
      const infoContainer = this.container.querySelector('#time-slider-segments-info');
      if (!infoContainer) return;

      if (this.segments.length === 0) {
        infoContainer.innerHTML = '';
        return;
      }

      const totalMinutes = this.segments.reduce((sum, s) => sum + s.minutes, 0);
      const totalHours = this.minutesToHours(totalMinutes);
      const isOverLimit = totalHours > 8;

      let html = '';

      this.segments.forEach((segment, index) => {
        const project = this.projects.find(p => p.id === segment.project_id);
        const color = this.getProjectColor(segment.project_id);
        const hours = this.minutesToHours(segment.minutes);

        const isEditingNote = this.editingNoteIndex === index;
        const hasNote = segment.comment && segment.comment.trim();
        
        html += `
          <div class="time-slider-segment-item" id="segment-item-${index}">
            <div class="time-slider-segment-item-info" style="flex: 1;">
              <div class="time-slider-segment-item-color" style="background: ${color.solid};"></div>
              <div style="flex: 1;">
                <div style="display: flex; align-items: center; gap: 12px;">
                  <span class="time-slider-segment-item-name">${project ? project.name : 'Unknown'}</span>
                  <span class="time-slider-segment-item-duration">${hours.toFixed(1)}h</span>
                </div>
                <div class="time-slider-segment-note-container" style="margin-top: 4px;">
                  ${isEditingNote ? `
                    <div style="display: flex; flex-direction: column; gap: 6px; width: 100%;">
                      <textarea 
                        class="time-slider-note-input"
                        id="note-input-${index}"
                        rows="3"
                        placeholder="Add note or tags (e.g., #meeting #setup)..."
                        style="width: 100%; padding: 4px 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg-primary); color: var(--text-primary); font-size: 11px; resize: vertical; min-height: 60px; font-family: inherit;"
                        autofocus
                      >${(segment.comment || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
                      <div style="display: flex; gap: 6px; justify-content: flex-end;">
                      <button 
                        class="time-slider-note-save"
                        id="note-save-${index}"
                          style="padding: 4px 8px; background: #14b8a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500;"
                      >
                        Save
                      </button>
                      <button 
                        class="time-slider-note-cancel"
                        id="note-cancel-${index}"
                          style="padding: 4px 8px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500;"
                      >
                        Cancel
                      </button>
                      </div>
                    </div>
                  ` : `
                    ${hasNote ? `
                      <div style="font-size: 11px; color: var(--text-secondary); padding: 2px 0;">
                        <span style="font-style: italic; white-space: pre-wrap; word-wrap: break-word; display: block; line-height: 1.4;">${segment.comment.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>
                        <button 
                          class="time-slider-edit-note"
                          data-note-index="${index}"
                          style="margin-top: 4px; background: none; border: none; color: var(--accent); cursor: pointer; font-size: 10px; text-decoration: underline;"
                        >
                          Edit
                        </button>
                      </div>
                    ` : `
                      <button 
                        class="time-slider-add-note"
                        data-note-index="${index}"
                        style="background: none; border: 1px dashed var(--border); color: var(--text-tertiary); cursor: pointer; font-size: 10px; text-decoration: none; padding: 2px 6px; border-radius: 3px; width: 100%; text-align: left;"
                      >
                        + Add note or tags
                      </button>
                    `}
                  `}
                </div>
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 16px;">
              <button class="time-slider-segment-item-remove" onclick="window.timeSliderInstance.removeSegment(${index})">
                Remove
              </button>
            </div>
          </div>
        `;
      });

      infoContainer.innerHTML = html;

      // Attach event listeners for note editing
      this.segments.forEach((segment, index) => {
        const addNoteBtn = infoContainer.querySelector(`[data-note-index="${index}"].time-slider-add-note`);
        const editNoteBtn = infoContainer.querySelector(`[data-note-index="${index}"].time-slider-edit-note`);
        const saveBtn = infoContainer.querySelector(`#note-save-${index}`);
        const cancelBtn = infoContainer.querySelector(`#note-cancel-${index}`);
        const input = infoContainer.querySelector(`#note-input-${index}`);
        
        if (addNoteBtn) {
          addNoteBtn.addEventListener('click', () => this.editNote(index));
        }
        if (editNoteBtn) {
          editNoteBtn.addEventListener('click', () => this.editNote(index));
        }
        if (saveBtn) {
          saveBtn.addEventListener('click', () => this.saveNote(index));
        }
        if (cancelBtn) {
          cancelBtn.addEventListener('click', () => this.cancelEditNote());
        }
        if (input) {
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
              e.preventDefault();
              this.cancelEditNote();
            }
            // Allow Enter in textarea, but Ctrl+Enter or Cmd+Enter to save
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
              e.preventDefault();
              this.saveNote(index);
            }
          });
        }
      });
    }

    editNote(index) {
      this.editingNoteIndex = index;
      this.render();
      // Focus input after render
      setTimeout(() => {
        const input = document.getElementById(`note-input-${index}`);
        if (input) {
          input.focus();
          input.select();
          // Scroll into view if needed
          input.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }, 50);
    }

    saveNote(index) {
      const input = document.getElementById(`note-input-${index}`);
      if (input && this.segments[index]) {
        this.segments[index].comment = input.value.trim() || null;
      }
      this.editingNoteIndex = null;
      this.render();
      this.scheduleSync();
    }

    cancelEditNote() {
      this.editingNoteIndex = null;
      this.render();
    }

    getSegmentsData() {
      return {
        segments: this.segments,
        totalHours: this.totalHours,
        date: this.date,
      };
    }

    setSegments(segments) {
      this.segments = segments;
      this.render();
    }

    setProjects(projects) {
      this.projects = projects;
      this.render();
    }
  }

  // Export for use
  window.TimeSlider = TimeSlider;
  }
</script>

